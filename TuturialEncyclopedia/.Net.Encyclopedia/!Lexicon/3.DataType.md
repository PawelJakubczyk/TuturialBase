### Value Types (Typy wartoœci)

> Value types store data directly. They are allocated on the stack (stos) and contain the actual data value. Examples of value types include:

1. **numeric types (Typy numeryczne)**:
    - `byte`: 8-bit integer (0 to 255)
    - `sbyte`: 8-bit signed integer (-128 to 127)
    - `short`: 16-bit signed integer (-32,768 to 32,767)
    - `ushort`: 16-bit integer (0 to 65,535)
    - `int`: 32-bit signed integer (-2,147,483,648 to 2,147,483,647)
    - `uint`: 32-bit integer (0 to 4,294,967,295)
    - `long`: 64-bit signed integer (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807)
    - `ulong`: 64-bit integer (0 to 18,446,744,073,709,551,615)

2. **Floating-point types (Typy zmiennoprzecinkowe)**:
    - `float`: 32-bit floating-point number
    - `double`: 64-bit floating-point number
    - `decimal`: 128-bit high-precision floating-point number, mainly used in financial applications

3. **Boolean types (Typy logiczne)**:
    - `bool`: Logical type that can be true or false

4. **Character types (Typy znakowe)**:
    - `char`: 16-bit type storing a single Unicode character

5. **Structures (Struktury)**:
    - `struct`: User-defined type that can contain various other value and reference types

6. **Enumeration types (Typy wyliczeniowe)**:
    - `enum`: Special value type defined by a set of named constants

### Reference Types (Typy referencji)

> Reference types store references to the actual data rather than the data itself. They are allocated on the heap (stercie). Examples of reference types include:

1. **Classes (Klasy)**:
    - `class`: Type defining an object containing data (fields) and functions (methods)

2. **Interfaces (Interfejsy)**:
    - `interface`: Type defining a contract that classes or structures can implement

3. **Arrays (Tablice)**:
    - `Array`: Type that stores a collection of elements of the same type

4. **String type (Typ string)**:
    - `string`: Type that stores a sequence of Unicode characters

5. **Object type (Typ object)**:
    - `object`: Base type for all types in C#

6. **Delegates (Delegaty)**:
    - `delegate`: Type representing a method and can hold references to one or multiple methods

7. **User-defined types (Typy zdefiniowane przez u¿ytkownika)**:
    - `class`, `interface`, `delegate`, and other user-defined reference types

```csharp
// Value types

int liczbaCalkowita = 42;             
double liczbaZmiennoprzecinkowa = 3.14; 
char znak = 'A';                      
bool logiczny = true;      

// Reference types

string tekst = "Hello, World!";       
object obiekt = new object();         
int[] tablica = {1, 2, 3, 4, 5};      

public class Osoba                   
{
    public string Imie { get; set; }
    public int Wiek { get; set; }
}
```

8. **Structure (Struktura)**:
    - **Definition (Definicja)**: A structure is a value type used to group related data together. Structures are similar to classes but differ in that they are stored on the stack rather than the heap.
    - **Example (Przyk³ad)**:

    ```csharp
    public struct Punkt
    {
        public int X { get; set; }
        public int Y { get; set; }
    }
    ```

9. **Enum (Wyliczenie)**:
    - **Definition (Definicja)**: An enum is a special data type representing a set of named constant values.
    - **Example (Przyk³ad)**:

    ```csharp
    public enum DniTygodnia
    {
        Poniedzialek,
        Wtorek,
        Sroda,
        Czwartek,
        Piatek,
        Sobota,
        Niedziela
    }
    ```

10. **Nullable types (Typy Nullable)**:
    - **Definition (Definicja)**: Nullable types allow storing null values in value types (e.g., `int`, `bool`).
    - **Example (Przyk³ad)**:

    ```csharp
    int? liczba = null;
    if (liczba.HasValue)
    {
        Console.WriteLine(liczba.Value);
    }
    else
    {
        Console.WriteLine("Brak wartoœci");
    }
    ```

11. **Tuple (Krotka)**:
    - **Definition (Definicja)**: A tuple is a data structure that can hold multiple elements of different types.
    - **Example (Przyk³ad)**:

    ```csharp
    var krotka = (1, "jeden", true);
    Console.WriteLine(krotka.Item1); // Output: 1
    Console.WriteLine(krotka.Item2); // Output: jeden
    Console.WriteLine(krotka.Item3); // Output: True
    ```

12. Dynamic Types (Typy dynamiczne)

- Typ dynamiczny pozwala na omijanie statycznego sprawdzania typów podczas kompilacji.
- Obiekty dynamiczne s¹ traktowane jak typ object, ale ró¿nica polega na tym, ¿e operacje na nich s¹ wykonywane dynamicznie w czasie wykonania.
- U¿ycie typu dynamicznego mo¿e prowadziæ do trudniejszego debugowania i potencjalnych b³êdów.

```csharp
dynamic dynamicVariable;

dynamicVariable = 42;
```

13. Type Object (typ objekt)
- Jest to najbardziej ogólny typ w C#.
- Mo¿e przechowywaæ dowolny obiekt, poniewa¿ wszystkie typy dziedzicz¹ po object.
- W praktyce oznacza to, ¿e mo¿emy przypisaæ do zmiennej typu object dowolny obiekt, ale tracimy informacje o jego rzeczywistym typie.
- Wymaga rzutowania (konwersji) na w³aœciwy typ przed u¿yciem.

```csharp
object myObject;

myObject = "Hello, world!";
Console.WriteLine(myObject); // "Hello, world!"

myObject = 42;
Console.WriteLine(myObject); // "42"

myObject = 3.14;
Console.WriteLine(myObject); // "3.14"
```

## Kolekcje(Colections)

Oczywiœcie! Poni¿ej znajdziesz krótkie opisy dla ka¿dej z tych kolekcji:

1. **Dictionary (S³ownik):**
   - **Opis:** S³ownik to kolekcja, w której przechowujemy pary klucz-wartoœæ. Ka¿dy klucz musi byæ unikalny, a wartoœæ mo¿e byæ dowolnego typu.
   - **Przyk³ad:**
     ```csharp
     Dictionary<string, int> myDictionary = new Dictionary<string, int>();
     myDictionary.Add("Jan", 30);
     myDictionary.Add("Anna", 25);
     int ageOfJan = myDictionary["Jan"]; // Pobranie wartoœci dla klucza "Jan"
     ```

2. **Hashtable:**
   - **Opis:** Hashtable to starsza implementacja s³ownika, dostêpna w .NET Framework. Dzia³a na zasadzie tablicy mieszaj¹cej (hash table), gdzie klucze s¹ haszowane, a wartoœci przechowywane w odpowiednich indeksach.
   - **Uwaga:** Hashtable jest mniej wydajne ni¿ Dictionary i nie obs³uguje typów generycznych.
   - **Przyk³ad:**
     ```csharp
     Hashtable myHashtable = new Hashtable();
     myHashtable.Add("Jan", 30);
     myHashtable.Add("Anna", 25);
     int ageOfJan = (int)myHashtable["Jan"]; // Pobranie wartoœci dla klucza "Jan"
     ```

3. **Array (Tablica):**
   - **Opis:** Tablica to kolekcja o sta³ym rozmiarze, przechowuj¹ca elementy tego samego typu. Indeksowanie tablicy odbywa siê za pomoc¹ liczb ca³kowitych.
   - **Przyk³ad:**
     ```csharp
     int[] myArray = new int[3] { 10, 20, 30 };
     int secondElement = myArray[1]; // Pobranie drugiego elementu (20)
     ```

4. **List:**
   - **Opis:** List to dynamiczna kolekcja, która automatycznie dostosowuje swój rozmiar do liczby przechowywanych elementów. Mo¿e przechowywaæ elementy ró¿nych typów.
   - **Przyk³ad:**
     ```csharp
     List<string> myList = new List<string>();
     myList.Add("Jan");
     myList.Add("Anna");
     string secondName = myList[1]; // Pobranie drugiego imienia ("Anna")
     ```

5. **Stack (Stos):**
   - **Opis:** Stos to kolekcja, w której elementy s¹ dodawane i pobierane w sposób LIFO (Last In, First Out). Mo¿emy dodawaæ elementy na wierzch stosu i usuwaæ je z niego.
   - **Przyk³ad:**
     ```csharp
     Stack<int> myStack = new Stack<int>();
     myStack.Push(10); // Dodanie elementu na wierzch stosu
     myStack.Push(20);
     int topElement = myStack.Pop(); // Pobranie i usuniêcie elementu z wierzchu (20)
     ```

6. **Queue (Kolejka):**
   - **Opis:** Kolejka to kolekcja, w której elementy s¹ dodawane na koñcu i pobierane z pocz¹tku w sposób FIFO (First In, First Out).
   - **Przyk³ad:**
     ```csharp
     Queue<string> myQueue = new Queue<string>();
     myQueue.Enqueue("Jan"); // Dodanie elementu na koniec kolejki
     myQueue.Enqueue("Anna");
     string firstPerson = myQueue.Dequeue(); // Pobranie i usuniêcie pierwszej osoby ("Jan")
     ```


